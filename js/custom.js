var container, stats;
var camera, scene, renderer;
var group;
var targetRotation = 0;
var targetRotationOnMouseDown = 0;
var mouseX = 0;
var mouseXOnMouseDown = 0;
var windowHalfX = window.innerWidth / 2;
init();
animate();

function init() {
  container = document.createElement('div');
  document.body.appendChild(container);
  var info = document.createElement('div');
  info.style.position = 'absolute';
  info.style.top = '10px';
  info.style.width = '100%';
  info.style.textAlign = 'center';
  info.innerHTML = 'Simple procedurally-generated shapes<br/>Drag to spin';
  container.appendChild(info);
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0xf0f0f0);
  camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
  camera.position.set(0, 150, 500);
  scene.add(camera);
  var light = new THREE.PointLight(0xffffff, 0.8);
  camera.add(light);
  group = new THREE.Group();
  group.position.y = 50;
  scene.add(group);
  var loader = new THREE.TextureLoader();
  var texture = loader.load("textures/UV_Grid_Sm.jpg");
  // it's necessary to apply these settings in order to correctly display the texture on a shape geometry
  texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
  texture.repeat.set(0.008, 0.008);

  function addShape(shape, extrudeSettings, color, x, y, z, rx, ry, rz, s) {
    // flat shape with texture
    // note: default UVs generated by ShapeBufferGeometry are simply the x- and y-coordinates of the vertices
    var geometry = new THREE.ShapeBufferGeometry(shape);
    var mesh = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial({
      side: THREE.DoubleSide,
      map: texture
    }));
    mesh.position.set(x, y, z - 175);
    mesh.rotation.set(rx, ry, rz);
    mesh.scale.set(s, s, s);
    group.add(mesh);
    // flat shape
    var geometry = new THREE.ShapeBufferGeometry(shape);
    var mesh = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial({
      color: color,
      side: THREE.DoubleSide
    }));
    mesh.position.set(x, y, z - 125);
    mesh.rotation.set(rx, ry, rz);
    mesh.scale.set(s, s, s);
    group.add(mesh);
    // extruded shape
    var geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
    var mesh = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial({
      color: color
    }));
    mesh.position.set(x, y, z - 75);
    mesh.rotation.set(rx, ry, rz);
    mesh.scale.set(s, s, s);
    group.add(mesh);
    addLineShape(shape, color, x, y, z, rx, ry, rz, s);
  }

  function addLineShape(shape, color, x, y, z, rx, ry, rz, s) {
    // lines
    shape.autoClose = true;
    var points = shape.getPoints();
    var spacedPoints = shape.getSpacedPoints(50);
    var geometryPoints = new THREE.BufferGeometry().setFromPoints(points);
    var geometrySpacedPoints = new THREE.BufferGeometry().setFromPoints(spacedPoints);
    // solid line
    var line = new THREE.Line(geometryPoints, new THREE.LineBasicMaterial({
      color: color,
      linewidth: 3
    }));
    line.position.set(x, y, z - 25);
    line.rotation.set(rx, ry, rz);
    line.scale.set(s, s, s);
    group.add(line);
    // line from equidistance sampled points
    var line = new THREE.Line(geometrySpacedPoints, new THREE.LineBasicMaterial({
      color: color,
      linewidth: 3
    }));
    line.position.set(x, y, z + 25);
    line.rotation.set(rx, ry, rz);
    line.scale.set(s, s, s);
    group.add(line);
    // vertices from real points
    var particles = new THREE.Points(geometryPoints, new THREE.PointsMaterial({
      color: color,
      size: 4
    }));
    particles.position.set(x, y, z + 75);
    particles.rotation.set(rx, ry, rz);
    particles.scale.set(s, s, s);
    group.add(particles);
    // equidistance sampled points
    var particles = new THREE.Points(geometrySpacedPoints, new THREE.PointsMaterial({
      color: color,
      size: 4
    }));
    particles.position.set(x, y, z + 125);
    particles.rotation.set(rx, ry, rz);
    particles.scale.set(s, s, s);
    group.add(particles);
  }

  
  // Spline shape
  var splinepts = [];
  splinepts.push(new THREE.Vector2(70, 20));
  splinepts.push(new THREE.Vector2(80, 90));
  splinepts.push(new THREE.Vector2(-30, 70));
  splinepts.push(new THREE.Vector2(0, 0));
  var splineShape = new THREE.Shape();
  splineShape.moveTo(0, 0);
  splineShape.splineThru(splinepts);
  var extrudeSettings = {
    amount: 8,
    bevelEnabled: true,
    bevelSegments: 2,
    steps: 2,
    bevelSize: 1,
    bevelThickness: 1
  };
  // addShape( shape, color, x, y, z, rx, ry,rz, s );
  // addShape(californiaShape, extrudeSettings, 0xf08000, -300, -100, 0, 0, 0, 0, 1);
  // addShape(triangleShape, extrudeSettings, 0x8080f0, -180, 0, 0, 0, 0, 0, 1);
  // addShape(roundedRectShape, extrudeSettings, 0x008000, -150, 150, 0, 0, 0, 0, 1);
  // addShape(trackShape, extrudeSettings, 0x008080, 200, -100, 0, 0, 0, 0, 1);
  // addShape(squareShape, extrudeSettings, 0x0040f0, 150, 100, 0, 0, 0, 0, 1);
  // addShape(heartShape, extrudeSettings, 0xf00000, 60, 100, 0, 0, 0, Math.PI, 1);
  // addShape(circleShape, extrudeSettings, 0x00f000, 120, 250, 0, 0, 0, 0, 1);
  // addShape(fishShape, extrudeSettings, 0x404040, -60, 200, 0, 0, 0, 0, 1);
  // addShape(smileyShape, extrudeSettings, 0xf000f0, -200, 250, 0, 0, 0, Math.PI, 1);
  // addShape(arcShape, extrudeSettings, 0x804000, 150, 0, 0, 0, 0, 0, 1);
  addShape(splineShape, extrudeSettings, 0x808080, -50, -100, 0, 0, 0, 0, 1);
  // addLineShape(arcShape.holes[0], 0x804000, 150, 0, 0, 0, 0, 0, 1);
  // for (var i = 0; i < smileyShape.holes.length; i += 1) {
  //   addLineShape(smileyShape.holes[i], 0xf000f0, -200, 250, 0, 0, 0, Math.PI, 1);
  // }
  //
  renderer = new THREE.WebGLRenderer({
    antialias: true
  });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  container.appendChild(renderer.domElement);
  stats = new Stats();
  container.appendChild(stats.dom);
  document.addEventListener('mousedown', onDocumentMouseDown, false);
  document.addEventListener('touchstart', onDocumentTouchStart, false);
  document.addEventListener('touchmove', onDocumentTouchMove, false);
  //
  window.addEventListener('resize', onWindowResize, false);
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}
//
function onDocumentMouseDown(event) {
  event.preventDefault();
  document.addEventListener('mousemove', onDocumentMouseMove, false);
  document.addEventListener('mouseup', onDocumentMouseUp, false);
  document.addEventListener('mouseout', onDocumentMouseOut, false);
  mouseXOnMouseDown = event.clientX - windowHalfX;
  targetRotationOnMouseDown = targetRotation;
}

function onDocumentMouseMove(event) {
  mouseX = event.clientX - windowHalfX;
  targetRotation = targetRotationOnMouseDown + (mouseX - mouseXOnMouseDown) * 0.02;
}

function onDocumentMouseUp(event) {
  document.removeEventListener('mousemove', onDocumentMouseMove, false);
  document.removeEventListener('mouseup', onDocumentMouseUp, false);
  document.removeEventListener('mouseout', onDocumentMouseOut, false);
}

function onDocumentMouseOut(event) {
  document.removeEventListener('mousemove', onDocumentMouseMove, false);
  document.removeEventListener('mouseup', onDocumentMouseUp, false);
  document.removeEventListener('mouseout', onDocumentMouseOut, false);
}

function onDocumentTouchStart(event) {
  if (event.touches.length == 1) {
    event.preventDefault();
    mouseXOnMouseDown = event.touches[0].pageX - windowHalfX;
    targetRotationOnMouseDown = targetRotation;
  }
}

function onDocumentTouchMove(event) {
  if (event.touches.length == 1) {
    event.preventDefault();
    mouseX = event.touches[0].pageX - windowHalfX;
    targetRotation = targetRotationOnMouseDown + (mouseX - mouseXOnMouseDown) * 0.05;
  }
}
//
function animate() {
  requestAnimationFrame(animate);
  render();
  stats.update();
}

function render() {
  group.rotation.y += (targetRotation - group.rotation.y) * 0.05;
  renderer.render(scene, camera);
}
